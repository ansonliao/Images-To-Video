package com.ansonliao.github;

import com.squareup.gifencoder.FloydSteinbergDitherer;
import com.squareup.gifencoder.GifEncoder;
import com.squareup.gifencoder.ImageOptions;
import org.jcodec.api.awt.AWTSequenceEncoder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.ansonliao.github.utils.ExceptionUtils.checkDirectoryExistedOrNot;
import static com.ansonliao.github.utils.ExceptionUtils.checkFileExistedOrNot;
import static com.ansonliao.github.utils.ImageUtils.isSupportedImageFormat;
import static java.util.stream.Collectors.toCollection;

public class ImagesToMovie {
    private static final Logger logger = LoggerFactory.getLogger(ImagesToMovie.class);
    private static final String IMAGE_HEIGHT_KEY = "height";
    private static final String IMAGE_WIDTH_KEY = "width";


    public static void main(String[] args) throws Exception {
        // File image1 = new File("/Users/ansonliao/repo/github/Images-To-Video/src/test/resources/image1.jpeg");
        // File image2 = new File("/Users/ansonliao/repo/github/Images-To-Video/src/test/resources/image2.jpeg");
        // File image3 = new File("/Users/ansonliao/repo/github/Images-To-Video/src/test/resources/image3.jpeg");
        // // ImageInputStream imageInputStream = ImageIO.createImageInputStream(new File("mygif.gif"));
        // // Iterator<ImageReader> readers = ImageIO.getImageReaders(imageInputStream);
        // // while (readers.hasNext()) {
        // //     ImageReader reader = readers.next();
        // //     System.out.println(reader.getFormatName());
        // //     System.out.println(reader.getHeight(0));
        // //     System.out.println(reader.getWidth(0));
        // // }
        //
        // // try (FileOutputStream outputStream = new FileOutputStream("my_animated_image.gif")) {
        // //     ImageOptions imageOptions = new ImageOptions();
        // //
        // // }
        // ImagesToMovie imagesToMovie = new ImagesToMovie();
        // // imagesToMovie.createAnimatedGif();
        Path testResourceDir = Paths.get("src", "test", "resources");
        String imageDir = testResourceDir.toFile().getPath();
        String gifFileName = Paths.get(imageDir, "animatedGif.gif").toFile().getAbsolutePath();
        System.out.println("GIF file path: " + gifFileName);
        ImagesToMovie imagesToMovie = new ImagesToMovie();
        imagesToMovie.createAnimatedGif(imageDir, gifFileName, true);

        System.out.println(Paths.get(gifFileName).toFile().exists());
    }

    public void createVideo(String imageDir, boolean isReversed, String videoLink) throws IOException {
        Stream<String> streamImages = getImages(imageDir).parallelStream().map(File::getAbsolutePath);
        ArrayList<String> images = isReversed
                ? streamImages.sorted(Comparator.reverseOrder()).collect(toCollection(ArrayList::new))
                : streamImages.sorted().collect(toCollection(ArrayList::new));
        logger.info("The video will be generated by the images from the directory: {}, video will be placed: {}", imageDir, videoLink);
        createVideo(images, videoLink);
    }

    // public void createGIF(List<String> imageLinks, String gifLink) {
    //     try (FileOutputStream fileOutputStream = new FileOutputStream(gifLink)) {
    //         ImageOptions imageOptions = new ImageOptions();
    //         imageOptions.setDelay(500, TimeUnit.MILLISECONDS);
    //         imageOptions.setDitherer(FloydSteinbergDitherer.INSTANCE);
    //         new GifEncoder(fileOutputStream, 500, 313, 0);
    //     } catch (FileNotFoundException e) {
    //         throw new RuntimeException(e);
    //     } catch (IOException e) {
    //         throw new RuntimeException(e);
    //     }
    // }

    public void createVideo(List<String> imageLinks, String videoLink) throws IOException {
        if (imageLinks == null || imageLinks.isEmpty()) {
            logger.info("No images provided to create video.");
            return;
        }

        logger.info("========== Generate Video From Images ==========");
        logger.info("Video fill will be generated: {}", videoLink);
        imageLinks.forEach(link -> logger.info("Image: {}", link));
        List<BufferedImage> bufferedImages = new ArrayList<>();
        for (String imageLink : imageLinks) {
            checkFileExistedOrNot(imageLink).throwMessage("Image file is not found, path: " + imageLink);
            bufferedImages.add(ImageIO.read(new File(imageLink)));
        }
        Path videoPath = Paths.get(videoLink).getParent();
        if (!Files.exists(videoPath)) {
            Files.createDirectory(videoPath);
        }

        AWTSequenceEncoder encoder = AWTSequenceEncoder.createSequenceEncoder(new File(videoLink), Configurations.getVideoConfigs().videoFps());
        for (BufferedImage bufferedImage : bufferedImages) {
            encoder.encodeImage(bufferedImage);
        }
        encoder.finish();

        logger.info("\nVideo has been generated at {}", videoLink);
        logger.info("================================================");
    }

    public void createAnimatedGif(List<File> imageList, String gifLink) throws IOException {
        Map<String, Integer> targetGifResolutionMap = getTheMaxResolutionOfImage(imageList);
        int targetGifHeight = targetGifResolutionMap.get(IMAGE_HEIGHT_KEY);
        int targetGitWidth = targetGifResolutionMap.get(IMAGE_WIDTH_KEY);

        System.out.println("height: " + targetGifHeight);
        System.out.println("width: " + targetGitWidth);
        try (FileOutputStream outputStream = new FileOutputStream(gifLink)) {
            ImageOptions options = new ImageOptions();

            // Set 500ms between each frame
            options.setDelay(500, TimeUnit.MILLISECONDS);
            // Use Floyd Steinberg dithering as it yields the best quality
            options.setDitherer(FloydSteinbergDitherer.INSTANCE);

            // Create GIF encoder with same dimension as of the source images
            GifEncoder gifEncoder = new GifEncoder(outputStream, targetGitWidth, targetGifHeight, 0);
            for (File image : imageList) {
                int imageHeigh = getImageResolution(image).get(IMAGE_HEIGHT_KEY);
                int imageWidth = getImageResolution(image).get(IMAGE_WIDTH_KEY);
                if (imageHeigh == targetGifHeight && imageWidth == targetGitWidth) {
                    gifEncoder.addImage(convertImageToArray(image), options);
                } else {
                    gifEncoder.addImage(convertImageToArray(resizeImage(image, targetGifHeight, targetGitWidth)), options);
                }
            }
            // start the encoding
            gifEncoder.finishEncoding();
        }
    }
    public void createAnimatedGif(String imageDir, String gifLink, boolean isReversed) throws Exception {
        Stream<String> streamImages = getImages(imageDir).parallelStream().map(File::getAbsolutePath);
        ArrayList<String> images = isReversed
                ? streamImages.sorted(Comparator.reverseOrder()).collect(toCollection(ArrayList::new))
                : streamImages.sorted().collect(toCollection(ArrayList::new));
        List<File> imageList = images.stream().map(imagePath -> Paths.get(imagePath).toFile()).collect(Collectors.toList());
        createAnimatedGif(imageList, gifLink);

        // List<File> imageList = getImages(imageDir);
        // Map<String, Integer> targetGifResolutionMap = getTheMaxResolutionOfImage(imageList);
        // int targetGifHeight = targetGifResolutionMap.get(IMAGE_HEIGHT_KEY);
        // int targetGitWidth = targetGifResolutionMap.get(IMAGE_WIDTH_KEY);
        // try (FileOutputStream outputStream = new FileOutputStream(gifLink)) {
        //     ImageOptions options = new ImageOptions();
        //
        //     // Set 500ms between each frame
        //     options.setDelay(500, TimeUnit.MILLISECONDS);
        //     // Use Floyd Steinberg dithering as it yields the best quality
        //     options.setDitherer(FloydSteinbergDitherer.INSTANCE);
        //
        //     // Create GIF encoder with same dimension as of the source images
        //     GifEncoder gifEncoder = new GifEncoder(outputStream, targetGitWidth, targetGifHeight, 0);
        //     for (File image : imageList) {
        //         int imageHeigh = getImageResolution(image).get(IMAGE_HEIGHT_KEY);
        //         int imageWidth = getImageResolution(image).get(IMAGE_WIDTH_KEY);
        //         if (imageHeigh == targetGifHeight && imageWidth == targetGitWidth) {
        //             gifEncoder.addImage(convertImageToArray(image), options);
        //         } else {
        //             gifEncoder.addImage(convertImageToArray(resizeImage(image, targetGifHeight, targetGitWidth)), options);
        //         }
        //     }
        //     // start the encoding
        //     gifEncoder.finishEncoding();
        // }
    }

    public List<File> getImages(String imageDir) throws IOException {
        checkDirectoryExistedOrNot(imageDir).throwMessage("The directory is not existed, path: " + imageDir);
        ArrayList<File> images = new ArrayList<>();
        File f = new File(imageDir);
        Arrays.stream(Objects.requireNonNull(f.listFiles())).filter(file -> isSupportedImageFormat(file.getName())).forEach(images::add);
        return images;
    }

    public Map<String, Integer> getTheMaxResolutionOfImage(List<File> images) throws IOException {
        List<BufferedImage> bufferedImages = new ArrayList<>();
        for (File image : images) {
            bufferedImages.add(ImageIO.read(image));
        }
        int maxHeight = bufferedImages.stream().map(BufferedImage::getHeight).max(Integer::compare).orElse(0);
        int maxWidth = bufferedImages.stream().map(BufferedImage::getWidth).max(Integer::compare).orElse(0);
        Map<String, Integer> result = new HashMap<>();
        result.put(IMAGE_HEIGHT_KEY, maxHeight);
        result.put(IMAGE_WIDTH_KEY, maxWidth);
        return result;
    }

    private Map<String, Integer> getImageResolution(File imageFile) throws IOException {
        Map<String, Integer> imagResolution = new HashMap<>();
        BufferedImage bufferedImage = ImageIO.read(imageFile);
        imagResolution.put(IMAGE_HEIGHT_KEY, bufferedImage.getHeight());
        imagResolution.put(IMAGE_WIDTH_KEY, bufferedImage.getWidth());
        return imagResolution;
    }

    public BufferedImage resizeImage(BufferedImage originalImage, int targetHeight, int targetWidth) {
        BufferedImage resizedImage = new BufferedImage(targetWidth, targetHeight, BufferedImage.TYPE_INT_RGB);
        Graphics2D graphics2D = resizedImage.createGraphics();
        graphics2D.drawImage(originalImage, 0, 0, targetWidth, targetHeight, null);
        graphics2D.dispose();
        return resizedImage;
    }

    public BufferedImage resizeImage(File imageFile, int targetHeight, int targetWidth) throws IOException {
        BufferedImage bufferedImage = ImageIO.read(imageFile);
        return resizeImage(bufferedImage, targetHeight, targetWidth);
    }

    /**
     * Convert image file into RGB pixel array
     *
     * @param file the file of the image
     * @return the two dimensions of the RGB array
     */
    public int[][] convertImageToArray(File file) throws IOException {
        BufferedImage bufferedImage = ImageIO.read(file);
        return convertImageToArray(bufferedImage);
        // int[][] rgbArray = new int[bufferedImage.getHeight()][bufferedImage.getWidth()];
        // for (int i = 0; i < bufferedImage.getHeight(); i++) {
        //     for (int j = 0; j < bufferedImage.getWidth(); j++) {
        //         rgbArray[i][j] = bufferedImage.getRGB(j, i);
        //     }
        // }
        // return rgbArray;
    }

    /**
     * Convert BufferedImage into RGB pixel array
     *
     * @param bufferedImage the image in buffered
     * @return the two dimensions of the RGB array
     */
    public int[][] convertImageToArray(BufferedImage bufferedImage) {
        int[][] rgbArray = new int[bufferedImage.getHeight()][bufferedImage.getWidth()];
        for (int i = 0; i < bufferedImage.getHeight(); i++) {
            for (int j = 0; j < bufferedImage.getWidth(); j++) {
                rgbArray[i][j] = bufferedImage.getRGB(j, i);
            }
        }
        return rgbArray;
    }
}
